/*
SpedV API

No description provided (generated by Openapi Generator https://github.com/openapitools/openapi-generator)

API version: v1
*/

// Code generated by OpenAPI Generator (https://openapi-generator.tech); DO NOT EDIT.

package openapi

import (
	"bytes"
	"context"
	"io"
	"net/http"
	"net/url"
	"strings"
	"time"
)


// OmsiAPIService OmsiAPI service
type OmsiAPIService service

type ApiV1OmsiDriventripsGetRequest struct {
	ctx context.Context
	ApiService *OmsiAPIService
	start *time.Time
	end *time.Time
}

func (r ApiV1OmsiDriventripsGetRequest) Start(start time.Time) ApiV1OmsiDriventripsGetRequest {
	r.start = &start
	return r
}

func (r ApiV1OmsiDriventripsGetRequest) End(end time.Time) ApiV1OmsiDriventripsGetRequest {
	r.end = &end
	return r
}

func (r ApiV1OmsiDriventripsGetRequest) Execute() ([]FPHSpedVAPIObjectsOMSIDrivenTrip, *http.Response, error) {
	return r.ApiService.V1OmsiDriventripsGetExecute(r)
}

/*
V1OmsiDriventripsGet Method for V1OmsiDriventripsGet

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiV1OmsiDriventripsGetRequest
*/
func (a *OmsiAPIService) V1OmsiDriventripsGet(ctx context.Context) ApiV1OmsiDriventripsGetRequest {
	return ApiV1OmsiDriventripsGetRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return []FPHSpedVAPIObjectsOMSIDrivenTrip
func (a *OmsiAPIService) V1OmsiDriventripsGetExecute(r ApiV1OmsiDriventripsGetRequest) ([]FPHSpedVAPIObjectsOMSIDrivenTrip, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  []FPHSpedVAPIObjectsOMSIDrivenTrip
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "OmsiAPIService.V1OmsiDriventripsGet")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/v1/omsi/driventrips"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.start != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "start", r.start, "")
	}
	if r.end != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "end", r.end, "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"text/plain", "application/json", "text/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["apikey"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["X-Api-Key"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiV1OmsiMapsGetRequest struct {
	ctx context.Context
	ApiService *OmsiAPIService
}

func (r ApiV1OmsiMapsGetRequest) Execute() ([]FPHSpedVAPIObjectsOMSIMap, *http.Response, error) {
	return r.ApiService.V1OmsiMapsGetExecute(r)
}

/*
V1OmsiMapsGet Method for V1OmsiMapsGet

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiV1OmsiMapsGetRequest
*/
func (a *OmsiAPIService) V1OmsiMapsGet(ctx context.Context) ApiV1OmsiMapsGetRequest {
	return ApiV1OmsiMapsGetRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return []FPHSpedVAPIObjectsOMSIMap
func (a *OmsiAPIService) V1OmsiMapsGetExecute(r ApiV1OmsiMapsGetRequest) ([]FPHSpedVAPIObjectsOMSIMap, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  []FPHSpedVAPIObjectsOMSIMap
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "OmsiAPIService.V1OmsiMapsGet")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/v1/omsi/maps"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"text/plain", "application/json", "text/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiV1OmsiMapsMapidBusstopsGetRequest struct {
	ctx context.Context
	ApiService *OmsiAPIService
	mapid int32
}

func (r ApiV1OmsiMapsMapidBusstopsGetRequest) Execute() ([]FPHSpedVAPIObjectsOMSIBusStop, *http.Response, error) {
	return r.ApiService.V1OmsiMapsMapidBusstopsGetExecute(r)
}

/*
V1OmsiMapsMapidBusstopsGet Method for V1OmsiMapsMapidBusstopsGet

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param mapid
 @return ApiV1OmsiMapsMapidBusstopsGetRequest
*/
func (a *OmsiAPIService) V1OmsiMapsMapidBusstopsGet(ctx context.Context, mapid int32) ApiV1OmsiMapsMapidBusstopsGetRequest {
	return ApiV1OmsiMapsMapidBusstopsGetRequest{
		ApiService: a,
		ctx: ctx,
		mapid: mapid,
	}
}

// Execute executes the request
//  @return []FPHSpedVAPIObjectsOMSIBusStop
func (a *OmsiAPIService) V1OmsiMapsMapidBusstopsGetExecute(r ApiV1OmsiMapsMapidBusstopsGetRequest) ([]FPHSpedVAPIObjectsOMSIBusStop, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  []FPHSpedVAPIObjectsOMSIBusStop
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "OmsiAPIService.V1OmsiMapsMapidBusstopsGet")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/v1/omsi/maps/{mapid}/busstops"
	localVarPath = strings.Replace(localVarPath, "{"+"mapid"+"}", url.PathEscape(parameterValueToString(r.mapid, "mapid")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"text/plain", "application/json", "text/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiV1OmsiMapsMapidDestinationsGetRequest struct {
	ctx context.Context
	ApiService *OmsiAPIService
	mapid int32
}

func (r ApiV1OmsiMapsMapidDestinationsGetRequest) Execute() ([]FPHSpedVAPIObjectsOMSIDestination, *http.Response, error) {
	return r.ApiService.V1OmsiMapsMapidDestinationsGetExecute(r)
}

/*
V1OmsiMapsMapidDestinationsGet Method for V1OmsiMapsMapidDestinationsGet

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param mapid
 @return ApiV1OmsiMapsMapidDestinationsGetRequest
*/
func (a *OmsiAPIService) V1OmsiMapsMapidDestinationsGet(ctx context.Context, mapid int32) ApiV1OmsiMapsMapidDestinationsGetRequest {
	return ApiV1OmsiMapsMapidDestinationsGetRequest{
		ApiService: a,
		ctx: ctx,
		mapid: mapid,
	}
}

// Execute executes the request
//  @return []FPHSpedVAPIObjectsOMSIDestination
func (a *OmsiAPIService) V1OmsiMapsMapidDestinationsGetExecute(r ApiV1OmsiMapsMapidDestinationsGetRequest) ([]FPHSpedVAPIObjectsOMSIDestination, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  []FPHSpedVAPIObjectsOMSIDestination
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "OmsiAPIService.V1OmsiMapsMapidDestinationsGet")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/v1/omsi/maps/{mapid}/destinations"
	localVarPath = strings.Replace(localVarPath, "{"+"mapid"+"}", url.PathEscape(parameterValueToString(r.mapid, "mapid")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"text/plain", "application/json", "text/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiV1OmsiMapsMapidGetRequest struct {
	ctx context.Context
	ApiService *OmsiAPIService
	mapid int32
}

func (r ApiV1OmsiMapsMapidGetRequest) Execute() (*FPHSpedVAPIObjectsOMSIMap, *http.Response, error) {
	return r.ApiService.V1OmsiMapsMapidGetExecute(r)
}

/*
V1OmsiMapsMapidGet Method for V1OmsiMapsMapidGet

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param mapid
 @return ApiV1OmsiMapsMapidGetRequest
*/
func (a *OmsiAPIService) V1OmsiMapsMapidGet(ctx context.Context, mapid int32) ApiV1OmsiMapsMapidGetRequest {
	return ApiV1OmsiMapsMapidGetRequest{
		ApiService: a,
		ctx: ctx,
		mapid: mapid,
	}
}

// Execute executes the request
//  @return FPHSpedVAPIObjectsOMSIMap
func (a *OmsiAPIService) V1OmsiMapsMapidGetExecute(r ApiV1OmsiMapsMapidGetRequest) (*FPHSpedVAPIObjectsOMSIMap, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *FPHSpedVAPIObjectsOMSIMap
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "OmsiAPIService.V1OmsiMapsMapidGet")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/v1/omsi/maps/{mapid}"
	localVarPath = strings.Replace(localVarPath, "{"+"mapid"+"}", url.PathEscape(parameterValueToString(r.mapid, "mapid")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"text/plain", "application/json", "text/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiV1OmsiMapsMapidStationlinksGetRequest struct {
	ctx context.Context
	ApiService *OmsiAPIService
	mapid int32
}

func (r ApiV1OmsiMapsMapidStationlinksGetRequest) Execute() ([]FPHSpedVAPIObjectsOMSIStationLink, *http.Response, error) {
	return r.ApiService.V1OmsiMapsMapidStationlinksGetExecute(r)
}

/*
V1OmsiMapsMapidStationlinksGet Method for V1OmsiMapsMapidStationlinksGet

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param mapid
 @return ApiV1OmsiMapsMapidStationlinksGetRequest
*/
func (a *OmsiAPIService) V1OmsiMapsMapidStationlinksGet(ctx context.Context, mapid int32) ApiV1OmsiMapsMapidStationlinksGetRequest {
	return ApiV1OmsiMapsMapidStationlinksGetRequest{
		ApiService: a,
		ctx: ctx,
		mapid: mapid,
	}
}

// Execute executes the request
//  @return []FPHSpedVAPIObjectsOMSIStationLink
func (a *OmsiAPIService) V1OmsiMapsMapidStationlinksGetExecute(r ApiV1OmsiMapsMapidStationlinksGetRequest) ([]FPHSpedVAPIObjectsOMSIStationLink, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  []FPHSpedVAPIObjectsOMSIStationLink
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "OmsiAPIService.V1OmsiMapsMapidStationlinksGet")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/v1/omsi/maps/{mapid}/stationlinks"
	localVarPath = strings.Replace(localVarPath, "{"+"mapid"+"}", url.PathEscape(parameterValueToString(r.mapid, "mapid")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"text/plain", "application/json", "text/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiV1OmsiMapsMapidToursGetRequest struct {
	ctx context.Context
	ApiService *OmsiAPIService
	mapid int32
}

func (r ApiV1OmsiMapsMapidToursGetRequest) Execute() ([]FPHSpedVAPIObjectsOMSITour, *http.Response, error) {
	return r.ApiService.V1OmsiMapsMapidToursGetExecute(r)
}

/*
V1OmsiMapsMapidToursGet Method for V1OmsiMapsMapidToursGet

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param mapid
 @return ApiV1OmsiMapsMapidToursGetRequest
*/
func (a *OmsiAPIService) V1OmsiMapsMapidToursGet(ctx context.Context, mapid int32) ApiV1OmsiMapsMapidToursGetRequest {
	return ApiV1OmsiMapsMapidToursGetRequest{
		ApiService: a,
		ctx: ctx,
		mapid: mapid,
	}
}

// Execute executes the request
//  @return []FPHSpedVAPIObjectsOMSITour
func (a *OmsiAPIService) V1OmsiMapsMapidToursGetExecute(r ApiV1OmsiMapsMapidToursGetRequest) ([]FPHSpedVAPIObjectsOMSITour, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  []FPHSpedVAPIObjectsOMSITour
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "OmsiAPIService.V1OmsiMapsMapidToursGet")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/v1/omsi/maps/{mapid}/tours"
	localVarPath = strings.Replace(localVarPath, "{"+"mapid"+"}", url.PathEscape(parameterValueToString(r.mapid, "mapid")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"text/plain", "application/json", "text/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiV1OmsiMapsMapidToursTouridGetRequest struct {
	ctx context.Context
	ApiService *OmsiAPIService
	mapid int32
	tourid int32
}

func (r ApiV1OmsiMapsMapidToursTouridGetRequest) Execute() (*FPHSpedVAPIObjectsOMSITour, *http.Response, error) {
	return r.ApiService.V1OmsiMapsMapidToursTouridGetExecute(r)
}

/*
V1OmsiMapsMapidToursTouridGet Method for V1OmsiMapsMapidToursTouridGet

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param mapid
 @param tourid
 @return ApiV1OmsiMapsMapidToursTouridGetRequest
*/
func (a *OmsiAPIService) V1OmsiMapsMapidToursTouridGet(ctx context.Context, mapid int32, tourid int32) ApiV1OmsiMapsMapidToursTouridGetRequest {
	return ApiV1OmsiMapsMapidToursTouridGetRequest{
		ApiService: a,
		ctx: ctx,
		mapid: mapid,
		tourid: tourid,
	}
}

// Execute executes the request
//  @return FPHSpedVAPIObjectsOMSITour
func (a *OmsiAPIService) V1OmsiMapsMapidToursTouridGetExecute(r ApiV1OmsiMapsMapidToursTouridGetRequest) (*FPHSpedVAPIObjectsOMSITour, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *FPHSpedVAPIObjectsOMSITour
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "OmsiAPIService.V1OmsiMapsMapidToursTouridGet")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/v1/omsi/maps/{mapid}/tours/{tourid}"
	localVarPath = strings.Replace(localVarPath, "{"+"mapid"+"}", url.PathEscape(parameterValueToString(r.mapid, "mapid")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"tourid"+"}", url.PathEscape(parameterValueToString(r.tourid, "tourid")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"text/plain", "application/json", "text/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiV1OmsiMapsMapidToursTouridTripsGetRequest struct {
	ctx context.Context
	ApiService *OmsiAPIService
	mapid int32
	tourid int32
	baseDate *time.Time
}

func (r ApiV1OmsiMapsMapidToursTouridTripsGetRequest) BaseDate(baseDate time.Time) ApiV1OmsiMapsMapidToursTouridTripsGetRequest {
	r.baseDate = &baseDate
	return r
}

func (r ApiV1OmsiMapsMapidToursTouridTripsGetRequest) Execute() ([]FPHSpedVAPIObjectsOMSITourTrip, *http.Response, error) {
	return r.ApiService.V1OmsiMapsMapidToursTouridTripsGetExecute(r)
}

/*
V1OmsiMapsMapidToursTouridTripsGet Method for V1OmsiMapsMapidToursTouridTripsGet

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param mapid
 @param tourid
 @return ApiV1OmsiMapsMapidToursTouridTripsGetRequest
*/
func (a *OmsiAPIService) V1OmsiMapsMapidToursTouridTripsGet(ctx context.Context, mapid int32, tourid int32) ApiV1OmsiMapsMapidToursTouridTripsGetRequest {
	return ApiV1OmsiMapsMapidToursTouridTripsGetRequest{
		ApiService: a,
		ctx: ctx,
		mapid: mapid,
		tourid: tourid,
	}
}

// Execute executes the request
//  @return []FPHSpedVAPIObjectsOMSITourTrip
func (a *OmsiAPIService) V1OmsiMapsMapidToursTouridTripsGetExecute(r ApiV1OmsiMapsMapidToursTouridTripsGetRequest) ([]FPHSpedVAPIObjectsOMSITourTrip, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  []FPHSpedVAPIObjectsOMSITourTrip
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "OmsiAPIService.V1OmsiMapsMapidToursTouridTripsGet")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/v1/omsi/maps/{mapid}/tours/{tourid}/trips"
	localVarPath = strings.Replace(localVarPath, "{"+"mapid"+"}", url.PathEscape(parameterValueToString(r.mapid, "mapid")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"tourid"+"}", url.PathEscape(parameterValueToString(r.tourid, "tourid")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.baseDate != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "baseDate", r.baseDate, "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"text/plain", "application/json", "text/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiV1OmsiMapsMapidTourtripsDateGetRequest struct {
	ctx context.Context
	ApiService *OmsiAPIService
	mapid int32
	date string
	timediff *int32
}

func (r ApiV1OmsiMapsMapidTourtripsDateGetRequest) Timediff(timediff int32) ApiV1OmsiMapsMapidTourtripsDateGetRequest {
	r.timediff = &timediff
	return r
}

func (r ApiV1OmsiMapsMapidTourtripsDateGetRequest) Execute() ([]FPHSpedVAPIObjectsOMSITour, *http.Response, error) {
	return r.ApiService.V1OmsiMapsMapidTourtripsDateGetExecute(r)
}

/*
V1OmsiMapsMapidTourtripsDateGet Method for V1OmsiMapsMapidTourtripsDateGet

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param mapid
 @param date
 @return ApiV1OmsiMapsMapidTourtripsDateGetRequest
*/
func (a *OmsiAPIService) V1OmsiMapsMapidTourtripsDateGet(ctx context.Context, mapid int32, date string) ApiV1OmsiMapsMapidTourtripsDateGetRequest {
	return ApiV1OmsiMapsMapidTourtripsDateGetRequest{
		ApiService: a,
		ctx: ctx,
		mapid: mapid,
		date: date,
	}
}

// Execute executes the request
//  @return []FPHSpedVAPIObjectsOMSITour
func (a *OmsiAPIService) V1OmsiMapsMapidTourtripsDateGetExecute(r ApiV1OmsiMapsMapidTourtripsDateGetRequest) ([]FPHSpedVAPIObjectsOMSITour, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  []FPHSpedVAPIObjectsOMSITour
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "OmsiAPIService.V1OmsiMapsMapidTourtripsDateGet")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/v1/omsi/maps/{mapid}/tourtrips/{date}"
	localVarPath = strings.Replace(localVarPath, "{"+"mapid"+"}", url.PathEscape(parameterValueToString(r.mapid, "mapid")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"date"+"}", url.PathEscape(parameterValueToString(r.date, "date")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.timediff != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "timediff", r.timediff, "")
	} else {
		var defaultValue int32 = 2
		r.timediff = &defaultValue
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"text/plain", "application/json", "text/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiV1OmsiMapsMapidTripsGetRequest struct {
	ctx context.Context
	ApiService *OmsiAPIService
	mapid int32
}

func (r ApiV1OmsiMapsMapidTripsGetRequest) Execute() ([]FPHSpedVAPIObjectsOMSITourTrip, *http.Response, error) {
	return r.ApiService.V1OmsiMapsMapidTripsGetExecute(r)
}

/*
V1OmsiMapsMapidTripsGet Method for V1OmsiMapsMapidTripsGet

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param mapid
 @return ApiV1OmsiMapsMapidTripsGetRequest
*/
func (a *OmsiAPIService) V1OmsiMapsMapidTripsGet(ctx context.Context, mapid int32) ApiV1OmsiMapsMapidTripsGetRequest {
	return ApiV1OmsiMapsMapidTripsGetRequest{
		ApiService: a,
		ctx: ctx,
		mapid: mapid,
	}
}

// Execute executes the request
//  @return []FPHSpedVAPIObjectsOMSITourTrip
func (a *OmsiAPIService) V1OmsiMapsMapidTripsGetExecute(r ApiV1OmsiMapsMapidTripsGetRequest) ([]FPHSpedVAPIObjectsOMSITourTrip, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  []FPHSpedVAPIObjectsOMSITourTrip
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "OmsiAPIService.V1OmsiMapsMapidTripsGet")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/v1/omsi/maps/{mapid}/trips"
	localVarPath = strings.Replace(localVarPath, "{"+"mapid"+"}", url.PathEscape(parameterValueToString(r.mapid, "mapid")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"text/plain", "application/json", "text/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}
